import {
  useForm,
  FormProvider,
  useFormContext,
  useWatch,
  useFieldArray,
} from "react-hook-form";
import { useEffect, useState } from "react";
// biome-ignore lint/style/useImportType: <explanation>
import { z } from "zod";
import { zodResolver } from "@hookform/resolvers/zod";
import {
  Form,
  useFetcher,
  useLoaderData,
  useNavigate,
} from "@remix-run/react";
import { data } from "@remix-run/node";
import UserExplanation from "~/components/SubmitFormComponents/UserExplanation";
import ClearFormButton from "~/components/SubmitFormComponents/ClearFormButton";
import { H1, H3 } from "~/components/Headings";
import TagSelectionBox from "~/components/SubmitFormComponents/TagSelectionBox";
import {
  getStopWords,
  getTagsCounts,
  prisma,
  updatePostWelcomed,
} from "~/modules/db.server";
import TagCreateBox from "~/components/SubmitFormComponents/TagCreateBox";
import TagPreviewBox from "~/components/SubmitFormComponents/TagPreviewBox";
import { Modal } from "~/components/Modal";
import type { ActionFunctionArgs, LoaderFunctionArgs, MetaFunction } from "@remix-run/node";
import { createEmbedding } from "~/modules/embedding.server";
import { FaCopy } from "react-icons/fa";
import { NodeHtmlMarkdown } from "node-html-markdown";
import { commonMetaFunction } from "~/utils/commonMetafunction";
import { toast, Toaster } from "react-hot-toast";
import { createPostFormSchema } from "~/schemas/post.schema";
import {
  getHashedUserIPAddress,
  getJudgeWelcomedByGenerativeAI,
  getTurnStileSiteKey,
  validateRequest,
} from "~/modules/security.server";
import { commitSession, getSession, isUserValid } from "~/modules/session.server";
import { Turnstile } from "@marsidev/react-turnstile";
import { MakeToastMessage } from "~/utils/makeToastMessage";

export async function loader({ request }: LoaderFunctionArgs) {
  const tags = await getTagsCounts();
  const stopWords = await getStopWords();
  const isValid = await isUserValid(request);
  const turnStileSiteKey = await getTurnStileSiteKey();
  return ({ tags, stopWords, isValid, turnStileSiteKey });
}

export default function App() {
  const { tags, stopWords, turnStileSiteKey } = useLoaderData<typeof loader>();
  const [selectedTags, setSelectedTags] = useState<string[]>([]);
  const [createdTags, setCreatedTags] = useState<string[]>([]);

  const postFormSchema = createPostFormSchema(stopWords);

  const handleTagSelection = (tags: string[]) => {
    setSelectedTags(tags);
    window.localStorage.setItem("selectedTags", JSON.stringify(tags));
    methods.setValue("selectedTags", tags);
  };

  const handleTagCreated = (tag: string) => {
    setCreatedTags([...createdTags, tag]);
    window.localStorage.setItem(
      "createdTags",
      JSON.stringify([...createdTags, tag])
    );
    methods.setValue("createdTags", [...createdTags, tag]);
  };

  const handleTagRemoved = (tag: string) => {
    setCreatedTags(createdTags.filter((t) => t !== tag));
    window.localStorage.setItem(
      "createdTags",
      JSON.stringify(createdTags.filter((t) => t !== tag))
    );
    methods.setValue(
      "createdTags",
      createdTags.filter((t) => t !== tag)
    );
  };

  const formId = "post-form";
  type Inputs = z.infer<typeof postFormSchema>;

  const getStoredValues = (): Inputs => {
    if (typeof window === "undefined")
      return {
        title: [],
        postCategory: "misDeed",
        situations: {
          who: "",
          what: "",
          when: "",
          where: "",
          why: "",
          how: "",
          // biome-ignore lint/suspicious/noThenProperty: <explanation>
          then: "",
        },
        reflection: [],
        counterReflection: [],
        note: [],
        selectedTags: [],
        createdTags: [],
      };
    const stored = window.localStorage.getItem(formId);
    return stored
      ? JSON.parse(stored)
      : {
          title: [],
          postCategory: "misDeed",
          situations: {
            who: "",
            what: "",
            when: "",
            where: "",
            why: "",
            how: "",
            // biome-ignore lint/suspicious/noThenProperty: <explanation>
            then: "",
          },
          reflection: [],
          counterReflection: [],
          note: [],
          selectedTags: [],
          createdTags: [],
        };
  };

  const methods = useForm({
    defaultValues: getStoredValues(),
    resolver: zodResolver(postFormSchema),
  });

  useEffect(() => {
    const interval = setInterval(() => {
      if (typeof window !== "undefined") {
        window.localStorage.setItem(
          formId,
          JSON.stringify(methods.getValues())
        );
      }
    }, 5000);
    return () => clearInterval(interval);
  }, [methods.getValues]);

  const postCategory = methods.watch("postCategory");

  const turnstileFetcher = useFetcher();
  const handleTurnStileSuccess = (token: string) => {
    const formData = new FormData();
    formData.append("token", token);
    formData.append("_action", "validateTurnstile");
    turnstileFetcher.submit(formData, { method: "post", action: "/post" });
  };

  useEffect(() => {
    const response = turnstileFetcher.data as { success: boolean };
    if (response?.success === false) {
      toast.error("„É™„ÇØ„Ç®„Çπ„ÉàÊ§úË®º„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÊôÇÈñì„Çí„Åä„ÅÑ„Å¶ÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ");
    }
    if (response?.success === true) {
      setIsFirstSubmitButtonOpen(true);
    }
  }, [turnstileFetcher.data]);

  const firstSubmitFetcher = useFetcher();
  const handleFirstSubmit = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();
    const inputValues = methods.getValues();
    const zodErrors = postFormSchema.safeParse(inputValues);
    if (!zodErrors.success) {
      const toastValidationMessage = MakeToastMessage(zodErrors.error.issues);
      toast.error(toastValidationMessage);
      return;
    }

    const formData = new FormData();
    formData.append("_action", "firstSubmit");
    for (const [key, value] of Object.entries(inputValues)) {
      formData.append(key, JSON.stringify(value));
    }
    firstSubmitFetcher.submit(formData, {
      method: "post",
      action: "/post",
    });
  };

  const [isPreviewModalOpen, setIsPreviewModalOpen] = useState(false);
  const [isFirstSubmitButtonOpen, setIsFirstSubmitButtonOpen] = useState(false);

  useEffect(() => {
    const response = firstSubmitFetcher.data as { success: boolean };
    if (response?.success) {
      setIsPreviewModalOpen(true);
    }
    if (response?.success === false) {
      toast.error("„Éó„É¨„Éì„É•„Éº„ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÊôÇÈñì„Çí„Åä„ÅÑ„Å¶ÂÜçÂ∫¶Ë©¶„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ");
    }
  }, [firstSubmitFetcher.data]);

  useEffect(() => {
    if (firstSubmitFetcher.state === "submitting") {
      toast.loading("„Éó„É¨„Éì„É•„Éº„ÇíÂèñÂæó„Åó„Å¶„ÅÑ„Åæ„Åô");
    }
    if (firstSubmitFetcher.state === "submitting") {
      setIsFirstSubmitButtonOpen(false);
    }
    if (firstSubmitFetcher.state === "loading") {
      setIsFirstSubmitButtonOpen(true);
      toast.dismiss();// „É≠„Éº„Éá„Ç£„É≥„Ç∞‰∏≠„ÅÆ„Éà„Éº„Çπ„Éà„ÇíÊ∂à„Åô
    }
  }, [firstSubmitFetcher.state]);

  const handleCopy = () => {
    const response = firstSubmitFetcher.data as { 
      data: { 
        data: { 
          MarkdownResult: string 
        } 
      } 
    };
    try {
      navigator.clipboard.writeText(response?.data?.data?.MarkdownResult);
      toast.success("„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åó„Åæ„Åó„Åü„ÄÇ");
    } catch (error) {
      toast.error("„ÇØ„É™„ÉÉ„Éó„Éú„Éº„Éâ„Å´„Ç≥„Éî„Éº„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ");
    }
  }

  const secondSubmitFetcher = useFetcher();
  const handleSecondSubmit = (e: React.MouseEvent<HTMLButtonElement>) => {
    e.preventDefault();
    const formData = new FormData();
    formData.append("_action", "secondSubmit");
    for (const [key, value] of Object.entries(methods.getValues())) {
      formData.append(key, JSON.stringify(value));
    }
    secondSubmitFetcher.submit(formData, { method: "post", action: "/post" });
  }
  const [isSecondSubmitButtonOpen, setIsSecondSubmitButtonOpen] = useState(true);
  
  useEffect(() => {
    if (secondSubmitFetcher.state === "submitting") {
      setIsSecondSubmitButtonOpen(false);
      toast.loading("ÊäïÁ®ø‰∏≠„Åß„Åô...")
    }
    if (secondSubmitFetcher.state === "loading" && (secondSubmitFetcher.data as { success: boolean })?.success === true) {
      toast.dismiss();
    }
  }, [secondSubmitFetcher.state, secondSubmitFetcher.data]);

  const navigate = useNavigate();
  useEffect(() => {
    const response = secondSubmitFetcher.data as { success: boolean, data: { postId: number } };
    if (response?.success === true && secondSubmitFetcher.state === "idle") {
      handleClearForm();
      toast.success("ÊäïÁ®ø„Åó„Åæ„Åó„Åü„ÄÇ„É™„ÉÄ„Ç§„É¨„ÇØ„Éà„Åó„Åæ„Åô...", {
        icon: "üéâ",
        id: "post-success-toast",
      })
      setTimeout(() => {
        const postId = response?.data?.postId;
        navigate(`/archives/${postId}`, { viewTransition: true });
      }, 2000);
    }
    return () => {
      toast.dismiss("post-success-toast");
    }
  }, [secondSubmitFetcher.data, navigate, secondSubmitFetcher.state]);

  const handleClearForm = () => {
    window.localStorage.removeItem(formId);
    window.localStorage.removeItem("selectedTags");
    window.localStorage.removeItem("createdTags");
    methods.reset({
      title: [""],
      postCategory: "misDeed",
      situations: {
        who: "",
        what: "",
        when: "",
        where: "",
        why: "",
        how: "",
        // biome-ignore lint/suspicious/noThenProperty: <explanation>
        then: "",
      },
      reflection: ["", "", ""],
      counterReflection: ["", "", ""],
      note: ["", "", ""],
      selectedTags: [],
      createdTags: [],
    });
    
    setSelectedTags([]);
    setCreatedTags([]);
  }

  return (
    <>
      <div className="templateSubmitForm">
        <FormProvider {...methods}>
          <Toaster />
          <Form method="post">
            <UserExplanation />
            <br />
            <div className="flex justify-start mt-6">
              <ClearFormButton clearInputs={handleClearForm} />
            </div>
            <br />
            <TextTypeSwitcher />
            <SituationInput />
            <DynamicTextInput
              description="Êõ∏„Åç„Åç„Çå„Å™„Åã„Å£„ÅüÂâçÊèêÊù°‰ª∂„ÅØ„ÅÇ„Çä„Åæ„Åô„ÅãÔºü"
              key="situations.assumption"
            />

            {postCategory === "misDeed" ? (
              <>
                <StaticTextInput
                  rowNumber={3}
                  title="ÂÅ•Â∏∏Ë°åÂãï„Éñ„É¨„Ç§„ÇØ„Éù„Ç§„É≥„Éà"
                  placeholders={[
                    "Âèã‰∫∫„ÅÆË®ÄÂãï„ÅØÂÜóË´á„Å†„Å®„ÅÑ„ÅÜ‰∫ã„Å´Ê∞ó„Åå‰ªò„ÅèÂøÖË¶Å„Åå„ÅÇ„Å£„Åü",
                    "‰ºöË©±„ÅÆ‰∏≠„ÅßËá™ÂàÜ„Åå„Åï„Çå„ÅüÊôÇ„Å´Âõ∞„Çã„Çà„ÅÜ„Å™„Éï„É™„ÅØÈÅø„Åë„Çã„Åπ„Åç„Åß„ÅÇ„Çã",
                  ]}
                  description="‰∏ä„ÅßË®òËø∞„Åó„ÅüÁä∂Ê≥Å„Åå„Å©„ÅÆ„Çà„ÅÜ„Å™ÁÇπ„Åß„Ç¢„Ç¶„Éà„Å†„Å£„Åü„ÅÆ„Åã„ÅÆË™¨Êòé„Åß„Åô„ÄÇ „Åß„Åç„ÇãÁØÑÂõ≤„ÅßÊßã„Çè„Å™„ÅÑ„ÅÆ„Åß„ÄÅ„Å™„Çã„Åπ„ÅèÁêÜÁî±„ÅØÊ∑±Â†Ä„Çä„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ „Äå„Éû„Éä„Éº„Å†„Åã„Çâ„Äç„ÅØÁêÜÁî±„Å®„Åó„Å¶„ÅØË™ç„ÇÅ„Çâ„Çå„Åæ„Åõ„Çì„ÄÇ ÂÅ•Â∏∏ËÄÖ„Ç®„Éü„É•„É¨„Éº„Çø„ÅØ„Éû„Éä„ÉºË¨õÂ∏´„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ‰∏Ä„Å§„Åö„Å§ËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ3„Å§Ë®òÂÖ•„Åô„ÇãÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ"
                  registerKey="reflection"
                />
                <StaticTextInput
                  rowNumber={3}
                  title="„Å©„ÅÜ„Åô„Çå„Å∞„Çà„Åã„Å£„Åü„Åã"
                  placeholders={[
                    "ÂÜóË´á„Å´ÂØæ„Åó„Å¶„Åü„Å†Á¨ë„ÅÜ„Åπ„Åç„Å†„Å£„Åü",
                    "Ë©†„Åæ„Åõ„ÅüÂæå„ÇÇ„Åù„ÅÆÂè•„ÇíÂ§ß„Åí„Åï„Å´Ë§í„ÇÅ„Çã„Å™„Å©„Åó„Å¶ÂæÆÂ¶ô„Å™Á©∫Ê∞ó„Å´„Åï„Åõ„Å™„ÅÑ„Åπ„Åç„Å†„Å£„Åü",
                  ]}
                  description="5W1HÁä∂Ë™¨Êòé„ÄÅÂÅ•Â∏∏Ë°åÂãï„Éñ„É¨„Ç§„ÇØ„Éù„Ç§„É≥„Éà„ÇíË∏è„Åæ„Åà„ÄÅ„Å©„ÅÆ„Çà„ÅÜ„Å´„Åô„Çã„Åπ„Åç„Å†„Å£„Åü„Åã„ÇíÊèêÁ§∫„Åó„Åæ„Åô„ÄÇ"
                  registerKey="counterReflection"
                />
              </>
            ) : postCategory === "goodDeed" ? (
              <>
                <StaticTextInput
                  rowNumber={3}
                  title="„Å™„Åú„ÇÑ„Å£„Å¶„Çà„Åã„Å£„Åü„ÅÆ„Åã"
                  placeholders={[
                    "‰∏ÄËà¨ÁöÑ„Å´ÊñôÁêÜ„Å®„ÅØÊâãÈñì„ÅÆ„Åã„Åã„Çã‰ΩúÊ•≠„Åß„ÅÇ„Çä„ÄÅÁõ∏Êâã„Åå„Åã„Åë„Å¶„Åè„Çå„ÅüÊâãÈñì„Å´ÂØæ„Åó„Å¶‰Ωï„Çâ„Åã„ÅÆÂΩ¢„ÅßÂ†±„ÅÑ„Çã„Åì„Å®„ÄÅ„ÇÇ„Åó„Åè„ÅØÂ†±„ÅÑ„ÇãÊÑèÊÄù„ÇíÁ§∫„Åô„Åì„Å®„ÅØÁõ∏Êâã„Å´ÂØæ„Åó„Å¶Êï¨ÊÑè„ÇíË°®„Åó„Å¶„ÅÑ„Çã„Åì„Å®„Å®Á≠â„Åó„ÅÑ„ÄÇ",
                    "Êï¨ÊÑè„ÅØ„Ç≥„Éü„É•„Éã„Ç±„Éº„Ç∑„Éß„É≥„Å´ÂØæ„Åó„Å¶ËâØ„ÅÑ‰ΩúÁî®„Çí„ÇÇ„Åü„Çâ„Åô",
                  ]}
                  description="‰∏ä„ÅßË®òËø∞„Åó„ÅüË°åÂãï„Åå„Å™„Åú„ÇÑ„Å£„Å¶„Çà„Åã„Å£„Åü„ÅÆ„Åã„ÄÅÁêÜÁî±„ÇíË™¨Êòé„Åó„Åæ„Åô„ÄÇ„Åß„Åç„ÇãÁØÑÂõ≤„ÅßÊßã„Çè„Å™„ÅÑ„ÅÆ„Åß„ÄÅ„Å™„Çã„Åπ„ÅèÁêÜÁî±„ÅØÊ∑±Â†Ä„Çä„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Å™„Çì„Å®„Å™„Åè„Åü„Å†„Äå„Çà„Åã„Å£„Åü„Äç„ÅØÁêÜÁî±„Å®„Åó„Å¶„ÅØË™ç„ÇÅ„Çâ„Çå„Åæ„Åõ„Çì„ÄÇ‰∏Ä„Å§„Åö„Å§ËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ3„Å§Ë®òÂÖ•„Åô„ÇãÂøÖË¶Å„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ"
                  registerKey="reflection"
                />
                <StaticTextInput
                  rowNumber={3}
                  title="„ÇÑ„Çâ„Å™„Åã„Å£„Åü„Çâ„Å©„ÅÜ„Å™„Å£„Å¶„ÅÑ„Åü„Åã"
                  placeholders={[
                    "Áõ∏Êâã„Åå„Åã„Åë„ÅüÊâãÈñì„Å´ÂØæ„Åó„Å¶Êï¨ÊÑè„Çí„Çè„Å™„ÅÑ„Åì„Å®„ÅØÁõ∏Êâã„ÇíÁÑ°‰∏ã„Å´Êâ±„Å£„Å¶„ÅÑ„Çã„Åì„Å®„Å®Á≠â„Åó„ÅÑ„ÄÇ",
                    "Èñ¢‰øÇ„ÅåÊîπÂñÑ„Åï„Çå„Çã„Åì„Å®„ÅØ„Å™„Åè„ÄÅÁä∂Ê≥Å„ÅåÊÇ™„Åë„Çå„Å∞Á†¥Â±Ä„Å´Ëá≥„Å£„Å¶„ÅÑ„Åü„Åã„ÇÇ„Åó„Çå„Å™„ÅÑ",
                  ]}
                  description="‰ªÆ„Å´‰∏ä„ÅßË®òËø∞„Åó„ÅüË°åÂãï„ÇíÂÆüË°å„Åó„Å™„Åã„Å£„ÅüÂ†¥Âêà„ÄÅ„Å©„ÅÆ„Çà„ÅÜ„Å™‰∏çÂà©Áõä„ÅåËµ∑„Åì„Çä„ÅÜ„Çã„ÅãË®òËø∞„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇÊé®Ë´ñ„ÅÆÁØÑÂõ≤ÂÜÖ„ÅßÊßã„Çè„Å™„ÅÑ„ÄÇ"
                  registerKey="counterReflection"
                />
              </>
            ) : postCategory === "wanted" ? (
              <>
                <StaticTextInput
                  rowNumber={3}
                  title="Ë©¶„Åó„Åü„Åì„Å®"
                  placeholders={[
                    "Ë∂£Âë≥„ÅÆË©±„Çí„Åó„Åü„Åì„Å®„Åå„ÅÇ„Çã„Åå„ÄÅÁ≠ÜËÄÖ„ÅÆË∂£Âë≥„ÅØ„Åã„Å™„Çä„Éû„Ç§„Éä„ÉºË∂£Âë≥„Åß„ÅÇ„Çä„ÄÅÂèçÂøú„Åå‰Ωï„ÇÇ„Å™„Åã„Å£„Åü",
                  ]}
                  description="ËÄÉ„Åà„Åü„ÇäÂÆüË°å„Åó„Åü„Çä„ÄÅË©¶„Åó„Å¶„Åø„Åü„Åì„Å®„ÇíË™¨Êòé„Åó„Åæ„Åô„ÄÇ„Åß„Åç„ÇãÁØÑÂõ≤„ÅßË®òËø∞„Åó„Å¶‰∏ã„Åï„ÅÑ„ÄÇ"
                  registerKey="reflection"
                />
                <StaticTextInput
                  rowNumber={3}
                  title="„Åæ„Å†„ÇÑ„Å£„Å¶„Å™„ÅÑ„Åì„Å®"
                  placeholders={[
                    "Â§©Ê∞ó„ÅÆË©±È°å„ÇíË©±„Åù„ÅÜ„Åã„Å®ÊÄù„Å£„Åü„Åå„ÄÅËá™Â∑±Á¥π‰ªã„ÅÆÊôÇ„Å´Ë©±„Åô„ÅÆ„ÅØÈÅï„ÅÜÊ∞ó„Åå„Åó„Åü",
                  ]}
                  description="Ëß£Ê±∫Á≠ñ„Å®„Åó„Å¶ËÄÉ„Åà„Åü„Åå„ÄÅ„Åæ„Å†ÂÆüË°å„Åó„Å¶„ÅÑ„Å™„ÅÑËÄÉ„Åà„ÇíË®òËø∞„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ„Å™„ÅÑÂ†¥Âêà„ÅØ„Äå„Å™„ÅÑ„Äç„Å®ÊòéË®ò„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
                  registerKey="counterReflection"
                />
              </>
            ) : null}
            <StaticTextInput
              rowNumber={3}
              title="ÂÇôËÄÉ"
              description="Êõ∏„Åç„Åç„Çå„Å™„Åã„Å£„Åü„Åì„Å®„ÇíÊõ∏„Åç„Åæ„Åô"
              placeholders={
                postCategory === "misDeed"
                  ? [
                      "Âèã‰∫∫„ÅåË©†„Çì„Å†Âè•„ÅØ„Äå„Åü„ÇÅÊ±†„ÇÑ Ê∞¥„Åå„ÅÑ„Å£„Å±„ÅÑ „Åç„Çå„ÅÑ„Å†„Å≠„Äç„Å†„Å£„Åü",
                    ]
                  : [
                      "Ëàå„ÅåÈÅéÂ∫¶„Å´ËÇ•„Åà„Å¶„Åó„Åæ„ÅÑ„ÄÅ„Ç≥„É≥„Éì„ÉãÂºÅÂΩì„ÅåÈ£ü„Åπ„Çâ„Çå„Å™„Åè„Å™„Å£„Åü„ÄÇ",
                    ]
              }
              registerKey="note"
            />
            <TagSelectionBox
              allTagsOnlyForSearch={tags}
              onTagsSelected={handleTagSelection}
              parentComponentStateValues={selectedTags}
            />
            <TagCreateBox
              handleTagCreated={handleTagCreated}
              handleTagRemoved={handleTagRemoved}
              parentComponentStateValues={createdTags}
            />
            <TagPreviewBox
              selectedTags={selectedTags}
              createdTags={createdTags}
            />
            <StaticTextInput
              rowNumber={1}
              title="„Çø„Ç§„Éà„É´"
              description="„Çø„Ç§„Éà„É´„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ"
              placeholders={["„Çø„Ç§„Éà„É´"]}
              registerKey="title"
            />
        <div className="flex justify-end">
          <div className="flex flex-col items-center gap-1 p-2">
            <Turnstile
              siteKey={turnStileSiteKey}
              onSuccess={handleTurnStileSuccess}
            />
            <button
              type="submit"
              className="btn btn-primary disabled:btn-disabled"
              onClick={handleFirstSubmit}
              disabled={!isFirstSubmitButtonOpen}
            >
              ÊäïÁ®ø„Åô„Çã
            </button>
            </div>
            <Modal
              isOpen={isPreviewModalOpen}
              onClose={() => setIsPreviewModalOpen(false)}
              title="ÊäïÁ®ø„Åô„ÇãÂÜÖÂÆπ„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
              showCloseButton={false}
            >
              <div className="postContent previewContainer">
                <H1>{(firstSubmitFetcher?.data as { data: { title: string } })?.data?.title}</H1>
                {/* biome-ignore lint/security/noDangerouslySetInnerHtml: <explanation> */}
                <div dangerouslySetInnerHTML={{ 
                  __html: (firstSubmitFetcher?.data as { data: { data: { WikifiedResult: string } } })?.data?.data?.WikifiedResult 
                }} />
              </div>
              <div className="flex justify-between items-center mt-6 border-t pt-8 border-gray-200">
                <button
                  type="button"
                  onClick={() => setIsPreviewModalOpen(false)}
                  className="btn btn-secondary"
                >
                  ‰øÆÊ≠£„Åô„Çã
                </button>
                <div className="flex flex-row items-center gap-1 p-2">
                  <button
                    type="button"
                    onClick={handleCopy}
                    className="btn btn-circle"
                  >
                    <FaCopy />
                  </button>
                </div>
                <button
                  type="button"
                  onClick={handleSecondSubmit}
                  className="btn btn-primary disabled:btn-disabled"
                  disabled={!isSecondSubmitButtonOpen}
                >
                  ÊäïÁ®ø„Åô„Çã
                </button>
              </div>
            </Modal>
          </div>
        </Form>
        </FormProvider>
      </div>
    </>
  );
}

function TextTypeSwitcher() {
  const { register } = useFormContext();
  return (
    <div className="mb-4">
      <H3>ÊäïÁ®ø„Çø„Ç§„Éó„ÇíÈÅ∏Êäû</H3>
      <p>ÊäïÁ®ø„Åó„Åü„ÅÑÁµåÈ®ìÁü•„ÅÆÁ®ÆÈ°û„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ</p>
      <div className="flex mt-4 rounded-lg border w-full p-4 flex-col gap-y-2">
        <div className="flex items-center gap-y-2 gap-x-2">
          <input
            type="radio"
            id="misDeed"
            value="misDeed"
            {...register("postCategory")}
            className="radio radio-primary"
          />
          <label htmlFor="misDeed">ÁµêÊûúÊÇ™Ôºö</label>
          <span className="text-sm">ÁµåÈ®ìÁü•„ÅÆ„ÅÜ„Å°„ÄÅ„ÇÑ„Å£„Å¶„ÅØ„ÅÑ„Åë„Å™„ÅÑ„Åì„Å®</span>
        </div>
        <div className="flex items-center gap-y-2 gap-x-2">
          <input
            type="radio"
            id="goodDeed"
            value="goodDeed"
            {...register("postCategory")}
            className="radio radio-primary"
          />
          <label htmlFor="goodDeed">ÁµêÊûúÂñÑÔºö</label>
          <span className="text-sm">ÁµåÈ®ìÁü•„ÅÆ„ÅÜ„Å°„ÄÅ„ÇÑ„Å£„Å¶„Çà„Åã„Å£„Åü„Åì„Å®</span>
        </div>
        <div className="flex items-center gap-y-2 gap-x-2">
          <input
            type="radio"
            id="wanted"
            value="wanted"
            {...register("postCategory")}
            className="radio radio-primary"
          />
          <label htmlFor="wanted">Áü•Ë≠òÂãüÈõÜÔºö</label>
          <span className="text-sm">
            Áü•„Çä„Åü„ÅÑ„Åì„Å®„ÄÅ„Çè„Åã„Çâ„Å™„ÅÑ„Åì„Å®„ÄÅÊÇ©„Çì„Åß„ÅÑ„Çã„Åì„Å®
          </span>
        </div>
      </div>
    </div>
  );
}

function SituationInput() {
  const {
    control,
    register,
    formState: { errors },
  } = useFormContext();
  const postCategory = useWatch({ control, name: "postCategory" });
  const placeholder =
    postCategory === "misDeed"
      ? [
          {
            key: "who",
            description: "„Åù„ÅÆÁä∂Ê≥Å„ÅÆ„Äå‰∏ªÂΩπ„Äç„ÅØË™∞„Åß„Åô„ÅãÔºü(Who)",
            placeholder: "Ëá™ÂàÜ„Åå",
            rows: 1,
          },
          {
            key: "when",
            description: "„ÅÑ„Å§Ëµ∑„Åì„Å£„Åü„Åì„Å®„Åß„Åô„ÅãÔºü(When)",
            placeholder: "Âèã‰∫∫„Å®ÂÖ¨Âúí„Å´„ÅÑ„ÅüÊôÇ",
            rows: 1,
          },
          {
            key: "where",
            description: "„Å©„Åì„ÅßËµ∑„Åì„Å£„Åü„Åì„Å®„Åß„Åô„ÅãÔºü(Where)",
            placeholder: "Ê±†„ÅÆÂâç„Åß",
            rows: 1,
          },
          {
            key: "why",
            description: "„Å™„Åú„Åù„ÅÆ„Çà„ÅÜ„Å™Ë°åÂãï„Çí„Åó„Åü„ÅÆ„Åß„Åô„ÅãÔºü(Why)",
            placeholder:
              "„ÄåË©†„ÇÅ„Åù„ÅÜ„Äç„Å®Ë®Ä„Çè„Çå„Åü„Çâ„Åù„ÅÜËøî„Åô„ÅÆ„ÅåËá™ÁÑ∂„Å™‰ºöË©±„ÅÆÊµÅ„Çå„Å†„Å®ÊÄù„Å£„Åü„Åã„Çâ",
            rows: 2,
          },
          {
            key: "what",
            description: "„Åù„ÅÆ‰∏ªÂΩπ„ÅØ„ÄÅ‰Ωï„Å´ÂØæ„Åó„Å¶„ÅØ„Åü„Çâ„Åç„Åã„Åë„Åæ„Åó„Åü„ÅãÔºü(What)",
            placeholder: "Âèã‰∫∫„Å´",
            rows: 1,
          },
          {
            key: "how",
            description: "„Åù„ÅÆ‰∏ªÂΩπ„ÅØ„ÄÅÂØæË±°„Çí„Å©„ÅÜ„Åó„Åæ„Åó„Åü„ÅãÔºü(How)",
            placeholder: "„ÄåË©†„Çì„Åß„Åø„Å¶„Çà„Äç„Å®Ë®Ä„Å£„Åü",
            rows: 1,
          },
          {
            key: "then",
            description: "Ë°åÂãï„ÅÆÁµêÊûú„Å®„Åó„Å¶„Å©„ÅÜ„Å™„Çä„Åæ„Åó„Åü„ÅãÔºü(Then)",
            placeholder: "Âèã‰∫∫„ÅåÂæÆÂ¶ô„Å™Âè•„ÇíË©†„Åø„ÄÅÂæÆÂ¶ô„Å™Á©∫Ê∞ó„Å´„Å™„Å£„Åü",
            rows: 3,
          },
        ]
      : postCategory === "goodDeed"
      ? [
          {
            key: "who",
            description: "„Åù„ÅÆÁä∂Ê≥Å„ÅÆ„Äå‰∏ªÂΩπ„Äç„ÅØË™∞„Åß„Åô„ÅãÔºü(Who)",
            placeholder: "Á≠ÜËÄÖ„Åå",
            rows: 1,
          },
          {
            key: "when",
            description: "„ÅÑ„Å§Ëµ∑„Åì„Å£„Åü„Åì„Å®„Åß„Åô„ÅãÔºü(When)",
            placeholder: "„Ç≥„É≠„Éä„ÅßÂêåÂ±Ö‰∫∫„ÅåÂÆ∂„Å´„ÅÑ„ÇãÊôÇÈñì„ÅåÂ¢ó„Åà„ÅüÊôÇ",
            rows: 1,
          },
          {
            key: "where",
            description: "„Å©„Åì„ÅßËµ∑„Åì„Å£„Åü„Åì„Å®„Åß„Åô„ÅãÔºü(Where)",
            placeholder: "ÂÆ∂„Åß",
            rows: 1,
          },
          {
            key: "why",
            description: "„Å™„Åú„Åù„ÅÆ„Çà„ÅÜ„Å™Ë°åÂãï„Çí„Åó„Åü„ÅÆ„Åß„Åô„ÅãÔºü(Why)",
            placeholder: "„Åä„ÅÑ„Åó„ÅÑ„Å®ÊÄù„Å£„Åü„Åü„ÇÅ",
            rows: 2,
          },
          {
            key: "what",
            description: "„Åù„ÅÆ‰∏ªÂΩπ„ÅØ„ÄÅ‰Ωï„Å´ÂØæ„Åó„Å¶„ÅØ„Åü„Çâ„Åç„Åã„Åë„Åæ„Åó„Åü„ÅãÔºü(What)",
            placeholder: "ÂêåÂ±Ö‰∫∫„Åå‰Ωú„Å£„Å¶„Åè„Çå„ÇãÊñôÁêÜ„Å´„Å§„ÅÑ„Å¶",
            rows: 1,
          },
          {
            key: "how",
            description: "„Åù„ÅÆ‰∏ªÂΩπ„ÅØ„ÄÅÂØæË±°„Çí„Å©„ÅÜ„Åó„Åæ„Åó„Åü„ÅãÔºü(How)",
            placeholder: "Áõ∏Êâã„Å´Áõ¥Êé•„Äå„Åä„ÅÑ„Åó„ÅÑ„Äç„Å®‰ºù„Åà„Çã„Çà„ÅÜ„Å´„Åó„Åü",
            rows: 1,
          },
          {
            key: "then",
            description: "Ë°åÂãï„ÅÆÁµêÊûú„Å®„Åó„Å¶„Å©„ÅÜ„Å™„Çä„Åæ„Åó„Åü„ÅãÔºü(Then)",
            placeholder:
              "Áõ∏Êâã„ÅÆÊñôÁêÜ„ÅÆËÖï„Åå‰∏ä„Åå„Çä„ÄÅ„Å©„Çì„Å©„ÇìÊñôÁêÜ„Åå„Åä„ÅÑ„Åó„Åè„Å™„Çä„ÄÅÈñ¢‰øÇ„ÇÇÊîπÂñÑ„Åï„Çå„Åü",
            rows: 3,
          },
        ]
      : postCategory === "wanted"
      ? [
          {
            key: "who",
            description: "„Åù„ÅÆÁä∂Ê≥Å„ÅÆ„Äå‰∏ªÂΩπ„Äç„ÅØË™∞„Åß„Åô„ÅãÔºü(Who)",
            placeholder: "Á≠ÜËÄÖ„Åå",
            rows: 1,
          },
          {
            key: "when",
            description: "„ÅÑ„Å§Ëµ∑„Åì„Å£„Åü„Åì„Å®„Åß„Åô„ÅãÔºü(When)",
            placeholder: "Á§æ‰ºö‰∫∫„Å™„Çä„Åü„Å¶„ÅÆÁèæÂú®„ÄÅÂàùÂØæÈù¢„ÅÆ‰∫∫„Å´„ÅÇ„ÅÑ„Åï„Å§„Åô„Çã„Å®„Åç",
            rows: 1,
          },
          {
            key: "where",
            description: "„Å©„Åì„ÅßËµ∑„Åì„Å£„Åü„Åì„Å®„Åß„Åô„ÅãÔºü(Where)",
            placeholder: "ËÅ∑Â†¥„Åß",
            rows: 1,
          },
          {
            key: "why",
            description: "„Å™„Åú„Åù„ÅÆ„Çà„ÅÜ„Å™Ë°åÂãï„Çí„Åó„Åü„ÅÆ„Åß„Åô„ÅãÔºü(Why)",
            placeholder: "‰Ωï„ÇíË©±„Åõ„Å∞ËâØ„ÅÑ„ÅÆ„Åã„Çè„Åã„Çâ„Å™„ÅÑ„Åü„ÇÅ",
            rows: 2,
          },
          {
            key: "what",
            description: "„Åù„ÅÆ‰∏ªÂΩπ„ÅØ„ÄÅ‰Ωï„Å´ÂØæ„Åó„Å¶„ÅØ„Åü„Çâ„Åç„Åã„Åë„Åæ„Åó„Åü„ÅãÔºü(What)",
            placeholder: "Áõ∏Êâã„Å´ÂØæ„Åó„Å¶",
            rows: 1,
          },
          {
            key: "how",
            description: "„Åù„ÅÆ‰∏ªÂΩπ„ÅØ„ÄÅÂØæË±°„Çí„Å©„ÅÜ„Åó„Åæ„Åó„Åü„ÅãÔºü(How)",
            placeholder: "„ÅÑ„Å§„ÇÇ„Åù„Å£„Åë„Å™„Åè„ÄÅÂêçÂâç„Å®ÊâÄÂ±û„Å†„ÅëË©±„Åó„Å¶„ÅÑ„Çã",
            rows: 1,
          },
          {
            key: "then",
            description: "Ë°åÂãï„ÅÆÁµêÊûú„Å®„Åó„Å¶„Å©„ÅÜ„Å™„Çä„Åæ„Åó„Åü„ÅãÔºü(Then)",
            placeholder:
              "ËÅ∑Â†¥„ÅÆ‰∫∫„Å®‰ª≤ËâØ„Åè„Å™„Çã„Åç„Å£„Åã„Åë„Åå„Å§„Åã„ÇÅ„Åö„ÄÅÂ≠§Áã¨„Çí„ÇÇ„Åü„Çâ„Åô‰∏ÄÂõ†„Å®„Å™„Å£„Åü",
            rows: 3,
          },
        ]
      : [];

  return (
    <div className="mb-8">
      <H3>5W1H+ThenÁä∂Ê≥ÅË™¨Êòé</H3>
      {placeholder.map((data, index) => {
        return (
          <div key={data.key} className="mb-4">
            <label htmlFor={data.key} className="block font-bold mb-2">
              {data.description}
            </label>
            <textarea
              id={data.key}
              placeholder={data.placeholder}
              rows={data.rows}
              className="w-full px-3 py-2 text-base-content border rounded-lg focus:outline-none placeholder-slate-500"
              {...register(`situations.${data.key}`)}
            />
            <div>
              {/* @ts-ignore */}
              {errors.situations?.[data.key] && (
                <ErrorMessageContainer
                  errormessage={
                    // @ts-ignore
                    errors.situations?.[data.key]?.message as string
                  }
                />
              )}
            </div>
          </div>
        );
      })}
    </div>
  );
}

function DynamicTextInput({
  description,
  registerKey = "situations.assumption",
}: {
  description: string;
  registerKey?: string;
}) {
  const { register, control } = useFormContext();
  const { fields, append, remove } = useFieldArray({
    control,
    name: registerKey,
  });
  return (
    <div className="mb-8">
      <H3>{description}</H3>
      <div className="flex mb-4 flex-col">
        {fields.map((field, index) => (
          <div key={field.id} className="flex flex-row my-2">
            <textarea
              key={field.id}
              {...register(`${registerKey}.${index}`)}
              className="w-3/4 border rounded-lg placeholder-slate-500 px-3 py-2"
            />
            <button
              type="button"
              onClick={() => remove(index)}
              className="bg-error text-error-content rounded-lg px-3 mx-3"
            >
              ÂâäÈô§
            </button>
          </div>
        ))}
      </div>
      <button
        type="button"
        onClick={() => append("")}
        className="bg-info text-info-content px-3 py-2 rounded-lg"
      >
        ËøΩÂä†
      </button>
    </div>
  );
}

function StaticTextInput({
  rowNumber,
  title,
  placeholders,
  description,
  registerKey,
}: {
  rowNumber: number;
  title: string;
  placeholders: string[];
  description: string;
  registerKey: string;
}) {
  const {
    register,
    formState: { errors },
  } = useFormContext();
  const renderTextInputs = () => {
    const inputs = [];
    for (let i = 0; i < rowNumber; i++) {
      inputs.push(
        <div className="w-full" key={`${title}-input-${i}`}>
          <textarea
            key={`${title}-input-${i}`}
            className="flex-grow px-3 py-2 border rounded-lg focus:outline-none w-full my-2 placeholder-slate-500"
            placeholder={placeholders[i]}
            {...register(`${registerKey}.${i}`)}
          />
          {errors[registerKey] && (
            <ErrorMessageContainer
              errormessage={errors[registerKey]?.root?.message as string}
            />
          )}
        </div>
      );
    }
    return inputs;
  };
  return (
    <div className="mb-8">
      <H3>{title}</H3>
      <p>{description}</p>
      <div className="flex items-center space-x-2 mb-4 flex-col">
        {renderTextInputs()}
      </div>
    </div>
  );
}

function ErrorMessageContainer({ errormessage }: { errormessage: string }) {
  return (
    <div>
      <p className="text-error">[!] {errormessage}</p>
    </div>
  );
}

export async function action({ request }: ActionFunctionArgs) {
  const formData = await request.formData();
  const actionType = formData.get("_action");
  const turnstileToken = formData.get("token");

  if (actionType === "validateTurnstile") {
    console.log("validateTurnstile has been called"); 
    const ipAddress = await getHashedUserIPAddress(request);
    const isValidatedByTurnstile = await validateRequest(
      turnstileToken as string,
      ipAddress
    );
    console.log("isValidatedByTurnstile", isValidatedByTurnstile);
    if (!isValidatedByTurnstile) {
      return data({ success: false, error: "„É™„ÇØ„Ç®„Çπ„Éà„ÅÆÊ§úË®º„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ" }, { status: 400 });
    }
    const session = await getSession(request.headers.get("Cookie"));
    session.set("isValidUser", true);
    return data(
      {
        success: true,
      },
      {
        headers: {
          "Set-Cookie": await commitSession(session),
        },
      }
    );
  }

  const postData = Object.fromEntries(formData);
  const stopWords = await getStopWords();
  const postFormSchema = createPostFormSchema(stopWords);
  type Inputs = z.infer<typeof postFormSchema>;

  const parsedData = {
    ...postData,
    postCategory: JSON.parse(postData.postCategory as string),
    situations: JSON.parse(postData.situations as string),
    reflection: JSON.parse(postData.reflection as string),
    counterReflection: JSON.parse(postData.counterReflection as string),
    note: JSON.parse(postData.note as string),
    selectedTags: JSON.parse((postData.selectedTags as string) || "[]"),
    createdTags: JSON.parse((postData.createdTags as string) || "[]"),
    title: JSON.parse(postData.title as string),
  } as unknown as Inputs;
  const isValidUser = await isUserValid(request); 
  if (!isValidUser) {
    return data({ success: false, error: "„É™„ÇØ„Ç®„Çπ„ÉàÊ§úË®º„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÊôÇÈñì„Çí„Åä„ÅÑ„Å¶ÂÜçÂ∫¶„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ" }, { status: 400 });
  }

  if (actionType === "firstSubmit") {
    try {
      const html = await Wikify(parsedData, postFormSchema);
      return data({
        success: true,
        data: { ...html.data, title: parsedData.title[0], tags: [...(parsedData.createdTags || []), ...(parsedData.selectedTags || [])] },
        error: undefined,
      });
    } catch (error) {
      return data({
        success: false,
        data: undefined,
        error: "Wikify failed",
      });
    }
  }

  if (actionType === "secondSubmit") {
    const html = await Wikify(parsedData, postFormSchema);
    const isSuccess = html.data.success;
    const wikifyResult = html.data?.data?.WikifiedResult;
    const postTitle = parsedData.title[0];
    const createdTags = parsedData.createdTags;
    const selectedTags = parsedData.selectedTags;
    if (!wikifyResult) {
      return data({ success: false, error: "Wikify failed", data: undefined });
    }

    if (isSuccess) {
      const hashedUserIpAddress = await getHashedUserIPAddress(request);
      if (html.data === undefined) {
        return data({
          success: false,
          error: "Wikify failed",
          data: undefined,
        }, { status: 400 });
      }
      const newPost = await prisma.$transaction(async (prisma) => {
        const newPost = await prisma.dimPosts.create({
          data: {
            postAuthorIPHash: hashedUserIpAddress,
            postContent: wikifyResult,
            postTitle: postTitle,
            countLikes: 0,
            countDislikes: 0,
            commentStatus: "open",
          },
        });
        const uniqueTags = [
          ...new Set([...(selectedTags || []), ...(createdTags || [])]),
        ];
        const existingTags = await prisma.dimTags.findMany({
          where: {
            tagName: {
              in: uniqueTags,
            },
          },
        });
        const existingTagNames = existingTags.map((tag) => tag.tagName);
        const newTagNames = uniqueTags.filter(
          (tag) => !existingTagNames.includes(tag)
        );
        const newTags = await Promise.all(
          newTagNames.map(async (tagName) => {
            return await prisma.dimTags.create({ data: { tagName } });
          })
        );
        const allTags = [...existingTags, ...newTags];
        await Promise.all(
          allTags.map(async (tag) => {
            return await prisma.relPostTags.create({
              data: { postId: newPost.postId, tagId: tag.tagId },
            });
          })
        );
        return newPost;
      });

      await createEmbedding({
        postId: Number(newPost.postId),
        postContent: newPost.postContent,
        postTitle: newPost.postTitle,
      });

      const { isWelcomed, explanation } = await getJudgeWelcomedByGenerativeAI(
        wikifyResult,
        postTitle
      );
      await updatePostWelcomed(Number(newPost.postId), isWelcomed, explanation);

      return data({
        success: true,
        error: undefined,
        data: { postId: newPost.postId },
      });
    }

    return data({ success: false, error: "Wikify failed", data: undefined }, { status: 400 });
  }
}

async function Wikify(
  postData: z.infer<ReturnType<typeof createPostFormSchema>>,
  postFormSchema: ReturnType<typeof createPostFormSchema>
) {
  // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥„ÇíÂÆüÊñΩ
  const validationResult = postFormSchema.safeParse(postData);
  if (!validationResult.success) {
    return data({
      success: false,
      error: validationResult.error.errors,
      data: undefined,
    }, { status: 400 });
  }

  const { who, when, where, why, what, how, then, assumption } =
    validationResult.data.situations;
  const { reflection, counterReflection } = validationResult.data;
  const { note, postCategory } = validationResult.data;

  function removeEmptyString(array: string[] | undefined): string[] {
    if (!array) return [];
    return array.filter((value) => !/^\s*$/.test(value));
  }

  const result = `
    <h3>5W1H+ThenÁä∂Ê≥ÅË™¨Êòé</h3>
    <table><tbody>
      <tr><td>Who(Ë™∞„Åå)</td><td>${who}</td></tr>
      <tr><td>When(„ÅÑ„Å§)</td><td>${when}</td></tr>
      <tr><td>Where(„Å©„Åì„Åß)</td><td>${where}</td></tr>
      <tr><td>Why(„Å™„Åú)</td><td>${why}</td></tr>
      <tr><td>What(‰Ωï„Çí)</td><td>${what}</td></tr>
      <tr><td>How(„Å©„ÅÆ„Çà„ÅÜ„Å´)</td><td>${how}</td></tr>
      <tr><td>Then(„Å©„ÅÜ„Åó„Åü)</td><td>${then}</td></tr>
    </tbody></table>
    ${
      removeEmptyString(assumption)?.length > 0
        ? `
      <h3>ÂâçÊèêÊù°‰ª∂</h3>
      <ul>
        ${removeEmptyString(assumption)
          ?.map((assumption) => `<li>${assumption}</li>`)
          .join("\n")}
      </ul>
      `
        : ""
    }
    <h3>
      ${
        postCategory === "misDeed"
          ? "ÂÅ•Â∏∏Ë°åÂãï„Éñ„É¨„Ç§„ÇØ„Éù„Ç§„É≥„Éà"
          : postCategory === "goodDeed"
          ? "„Å™„Åú„ÇÑ„Å£„Å¶„Çà„Åã„Å£„Åü„ÅÆ„Åã"
          : postCategory === "wanted"
          ? "Ë©¶„Åó„Åü„Åì„Å®"
          : ""
      }
    </h3>
    <ul>
      ${removeEmptyString(reflection)
        ?.map((reflection) => `<li>${reflection}</li>`)
        .join("\n")}
    </ul>
    <h3>
      ${
        postCategory === "misDeed"
          ? "„Å©„ÅÜ„Åô„Çå„Å∞„Çà„Åã„Å£„Åü„Åã"
          : postCategory === "goodDeed"
          ? "„ÇÑ„Çâ„Å™„Åã„Å£„Åü„Çâ„Å©„ÅÜ„Å™„Å£„Å¶„ÅÑ„Åü„Åã"
          : postCategory === "wanted"
          ? "„Åæ„Å†„ÇÑ„Å£„Å¶„Å™„ÅÑ„Åì„Å®"
          : ""
      }
    </h3>
    <ul>
      ${removeEmptyString(counterReflection)
        ?.map((counterReflection) => `<li>${counterReflection}</li>`)
        .join("\n")}
    </ul>
    ${
      removeEmptyString(note)?.length > 0
        ? `
      <h3>ÂÇôËÄÉ</h3>
      <ul>
        ${removeEmptyString(note)
          ?.map((note) => `<li>${note}</li>`)
          .join("\n")}
      </ul>
    `
        : ""
    }
  `;
  const markdownContent = NodeHtmlMarkdown.translate(result);
  return data({
    success: true,
    error: undefined,
    data: { WikifiedResult: result, MarkdownResult: markdownContent },
  });
}

export const meta: MetaFunction = () => {
  const commonMeta = commonMetaFunction({
    title: "ÊäïÁ®ø„Åô„Çã",
    description: "„ÉÜ„É≥„Éó„É¨„Éº„Éà„Å´Ê≤ø„Å£„Å¶ÊäïÁ®ø„Åô„Çã",
    url: "https://healthy-person-emulator.org/post",
    image: null,
  });
  return commonMeta;
};
